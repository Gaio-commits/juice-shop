name: Security Audit

on:
  workflow_dispatch:
    inputs:
      security_checks_enabled:
        description: 'Rodar checks?'
        required: true
        default: true
        type: boolean

  # Roda automático toda vez que subir código
  push:
    branches:
      - 'feature/appsec-workflow'
    #  - main  <--- Comentando a main por enquanto para não rodar em produção
permissions:
  contents: read
  security-events: write
  actions: read
  
jobs:

  # =====================================================================================
  # ETAPA 1: ANÁLISE ESTÁTICA DE SEGURANÇA DE APLICAÇÃO (SAST)
  # Objetivo: Analisar o código-fonte em busca de padrões de
  # vulnerabilidades conhecidas, sem executar a aplicação.
  # Ferramentas: Semgrep
  # =====================================================================================
  sast-analysis:
    name: Análise Estática de Segurança (SAST com Semgrep)
    runs-on: ubuntu-latest
    permissions: # Permissões necessárias para as actions deste job
      actions: read 
      contents: read     # Para fazer checkout do código
      security-events: write # Para Semgrep enviar resultados para a aba Security
    steps:
    
      # Passo 1.1: Baixar o código-fonte do fork do leitor.
      # As ferramentas SAST analisarão este código.
      - name: Checkout do código do repositório (fork do leitor)
        uses: actions/checkout@v4
        
        # Por padrão, faz checkout do branch que acionou o workflow.
        # Se quiser sempre analisar uma branch específica do fork (ex: 'develop'),
        # ele pode adicionar:
        # with:
        #   ref: 'develop'

      # --- SAST com Semgrep ---
      # Passo 1.2: Instalar a ferramenta Semgrep.
      - name: Configurar Semgrep
        run: pip install semgrep

      # Passo 1.3: Executar o Semgrep com um conjunto de regras padrão (p/default).
      # O resultado é salvo no formato SARIF.
      # "|| true" garante que o workflow continue mesmo se o Semgrep encontrar vulnerabilidades.
      - name: Executar Semgrep
        run: |
          semgrep scan --config "p/default" --sarif --output semgrep.sarif || true
          echo "--- Resumo Rápido ---"
          semgrep scan --config "p/default" --text || true

      # Passo 1.4: Fazer upload do relatório SARIF (atualmente .txt) do Semgrep como um artefato do workflow.
      # Isso permite que o leitor baixe e analise o relatório completo.
      - name: Upload do relatório SARIF do Semgrep (Artefato para download)
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: semgrep.sarif
          if-no-files-found: warn # Apenas avisa se o arquivo não for encontrado

      # Passo 1.5: Enviar o relatório SARIF do Semgrep para a aba "Security" -> "Code scanning alerts" do GitHub.
      - name: Upload do resultado SARIF do Semgrep para GitHub Security
        #"hashFiles('semgrep.sarif') != ''" garante que só tentamos o upload se o arquivo existir e não estiver vazio.
        if: always() && hashFiles('semgrep.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: semgrep.sarif
          category: semgrep-lopti # Categoria para agrupar os alertas no GitHub

  # =====================================================================================
  # ETAPA 2: ANÁLISE DE COMPOSIÇÃO DE SOFTWARE (SCA) E GERAÇÃO DE SBOM
  # Objetivo: Identificar componentes de terceiros (dependências)
  # e suas vulnerabilidades conhecidas. Também geraremos um Software Bill of Materials (SBOM).
  # Ferramentas: Syft e OWASP Dependency-Check
  # =====================================================================================
  sca-analysis:
    name: Análise de Composição de Software (SCA) e SBOM
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      # 1. Gerar data para as chaves de cache (Evita baixar o NVD todo do zero)
      - name: Get current date
        id: set-date # Precisamos desse ID para referenciar depois
        run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

      # 2. Configurar Node com Cache Nativo
      - name: Configurar Node.js e Cache
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm' # Ativa o cache automático da pasta ~/.npm

      # 3. Instalação Única e Otimizada
      - name: Instalar Dependências
        run: |
          echo "Instalando dependências com flags de performance..."
          # --prefer-offline: Usa o cache se disponível
          # --no-audit: Não roda o audit do npm
          npm install --prefer-offline --no-audit --no-fund
          if [ -d "frontend" ]; then cd frontend && npm install --prefer-offline --no-audit --no-fund && cd ..; fi

      # 4. Gerar SBOM com Syft
      - name: Gerar SBOM com Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft . -o cyclonedx-json=bom.json
        shell: bash

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: bom.json

      # --- SCA com OWASP Dependency-Check ---
      - name: Configurar Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      # 5. CACHE DO BANCO NVD (O segredo para velocidade no scan)
      - name: Cache do banco de dados NVD
        uses: actions/cache@v4
        with:
          path: ~/.dependency-check/data
          # Referenciamos o output do step 'set-date'
          key: ${{ runner.os }}-nvd-db-${{ steps.set-date.outputs.date }}
          restore-keys: |
            ${{ runner.os }}-nvd-db-

      - name: Instalar OWASP Dependency-Check
        run: |
          DC_VERSION="12.1.0"
          wget https://github.com/jeremylong/DependencyCheck/releases/download/v${DC_VERSION}/dependency-check-${DC_VERSION}-release.zip -O $RUNNER_TEMP/dc.zip
          unzip -q $RUNNER_TEMP/dc.zip -d $RUNNER_TEMP/dependency-check

      - name: Executar OWASP Dependency-Check
        continue-on-error: true
        env:
          JAVA_OPTS: "-Xmx6g"
          OSSINDEX_USER: ${{ secrets.OSS_INDEX_USER }}
          OSSINDEX_PASSWORD: ${{ secrets.OSS_INDEX_KEY }}
        run: |
          mkdir -p reports
          $RUNNER_TEMP/dependency-check/dependency-check/bin/dependency-check.sh \
            --scan . \
            --project "Lopti-App-Sec" \
            --format SARIF \
            --out dependency-check-results.sarif \
            --enableExperimental \
            --nvdApiKey ${{ secrets.NVD_API_KEY }} \
            --disableAssembly \
            --exclude "**/node_modules/**" \
            --exclude "**/build/**" \
            --exclude "**/dist/**" \
            --exclude "**/*.js" \
            --exclude "$RUNNER_TEMP/**" \
            --failOnCVSS 11

      - name: Upload Relatório SCA
        uses: actions/upload-artifact@v4
        with:
          name: Dependency-Check-Results
          path: dependency-check-results.sarif

      - name: Enviar para GitHub Security
        if: always() && hashFiles('dependency-check-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: dependency-check-results.sarif
          category: owasp-dependency-check

  # =====================================================================================
  # ETAPA 3: SCAN DE SEGREDOS
  # Objetivo: Verificar se há segredos (senhas, chaves de API, tokens) commitados
  # acidentalmente no código-fonte do fork, INCLUINDO O HISTÓRICO COMPLETO.
  # Ferramenta: Gitleaks
  # =====================================================================================
  secrets-scan:
    name: Varredura de Segredos com Gitleaks
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: Checkout do código (com histórico completo)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Executar Gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
        # A action irá gerar 'results.sarif' e fazer o upload como artefato automaticamente.
        # As variáveis de ambiente para nome do arquivo são ignoradas.

      - name: Upload do resultado SARIF do Gitleaks para GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: results.sarif
          category: gitleaks 
          
  # ===========================================================================
  # ETAPA 4: SCAN DO SISTEMA DE ARQUIVOS
  # Objetivo: Escanear o código fonte atual (.) em busca de vulns e misconfigs
  # sem precisar criar uma imagem Docker.
  # Ferramentas: Trivy
  # ===========================================================================
  trivy-scan-fs:
    name: Scan de Código/Config (Trivy FS)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Executar Trivy (Filesystem)
        uses: aquasecurity/trivy-action@0.29.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'                
          output: 'trivy-fs-results.sarif' 
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '0'                 # Garante que não quebra o build

      - name: Upload Relatório Trivy (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: Relatorio-Config-Trivy
          path: trivy-fs-results.sarif

      - name: Enviar para GitHub Security
        if: always() && hashFiles('trivy-fs-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4 
        with:
          sarif_file: 'trivy-fs-results.sarif'
          category: trivy-fs
